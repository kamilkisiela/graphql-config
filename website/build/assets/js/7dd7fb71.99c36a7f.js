(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{78:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return p}));var o=t(3),r=t(7),a=(t(0),t(93)),i={id:"extensions",title:"Writing and Consuming Extensions",sidebar_label:"Extensions"},s={unversionedId:"extensions",id:"extensions",isDocsHomePage:!1,title:"Writing and Consuming Extensions",description:"The main purpose of GraphQL Config Extensions is to pass information to extension's consumer in order to extend the behavior of GraphQL Config's logic.",source:"@site/docs/author-extensions.md",slug:"/extensions",permalink:"/extensions",editUrl:"https://github.com/kamilkisiela/graphql-config/edit/master/website/docs/author-extensions.md",version:"current",sidebar_label:"Extensions",sidebar:"docs",previous:{title:"Loading Config",permalink:"/load-config"},next:{title:"Loaders",permalink:"/loaders"}},c=[{value:"How to write extensions",id:"how-to-write-extensions",children:[{value:"Schema Middlewares",id:"schema-middlewares",children:[]}]},{value:"Consuming extension",id:"consuming-extension",children:[]},{value:"Registering Loaders",id:"registering-loaders",children:[]}],l={toc:c};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The main purpose of GraphQL Config Extensions is to pass information to extension's consumer in order to extend the behavior of GraphQL Config's logic."),Object(a.b)("p",null,"GraphQL Config ships TypeScript declaration files so let's make use of them in following examples."),Object(a.b)("h2",{id:"how-to-write-extensions"},"How to write extensions"),Object(a.b)("p",null,"In order to make sure you write extensions correctly, import and use the",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLExtensionDeclaration")," type from ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-config")," package. Thanks to TypeScript, you get autocompletion and in-editor validation."),Object(a.b)("p",null,"The main requirement of an extension is its name. Providing a name lets GraphQL Config to match the extension with its namespace in the config file."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"import {GraphQLExtensionDeclaration} from 'graphql-config';\n\nconst InspectorExtension: GraphQLExtensionDeclaration = (api) => {\n  return {\n    name: 'inspector',\n  };\n};\n")),Object(a.b)("h3",{id:"schema-middlewares"},"Schema Middlewares"),Object(a.b)("p",null,"GraphQL Config lets you intercept the GraphQL Schema loading process which may be helpful when dealing with custom directives like in Relay or Apollo Federation. We call it Middlewares."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"import {GraphQLExtensionDeclaration} from 'graphql-config';\n\nconst RelayExtension: GraphQLExtensionDeclaration = (api) => {\n  api.loaders.schema.use((document) => {\n    // The middleware receives a DocumentNode object\n    // Adds relay directives\n    // Returns a new DocumentNode\n    return addRelayToDocumentNode(document);\n  });\n\n  return {\n    name: 'relay',\n  };\n};\n")),Object(a.b)("h2",{id:"consuming-extension"},"Consuming extension"),Object(a.b)("p",null,"As a GraphQL tool author you will likely want to load the config and register your extension in order to understand user's configuration."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"import {loadConfig} from 'graphql-config';\nimport {InspectorExtension} from './extension';\n\nasync function main() {\n  const config = await loadConfig({\n    extensions: [InspectorExtension],\n  });\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Synchronous version: ",Object(a.b)("inlineCode",{parentName:"p"},"loadConfigSync"))),Object(a.b)("p",null,"Now that everything is ready, GraphQL Config understands there's the Inspector extension."),Object(a.b)("p",null,"In order to access information stored in the config file, do the following:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"async function main() {\n  // ... code from previous steps\n\n  // Reads configuration of a default project\n  const project = config.getDefault();\n  // Reads configuration of a named project\n  const project = config.getProject('admin');\n\n  // Reads extenion's configuration defined in a project\n  const inspectorConfig = project.extension('inspector');\n\n  // Given following config file:\n  //\n  // schema: './schema.graphql'\n  // extensions:\n  //  inspector:\n  //    validate: true\n  //\n\n  // You're able to get `validate`:\n  if (inspectorConfig.validate === true) {\n    // ...\n  }\n}\n")),Object(a.b)("p",null,"Getting ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," is straightforward: each project has ",Object(a.b)("inlineCode",{parentName:"p"},"getSchema(): Promise<GraphQLSchema>")," method."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"async function main() {\n  // ... code from the previous example\n  if (inspectorConfig.validate === true) {\n    const schema = await project.getSchema();\n\n    validateSchema(schema);\n  }\n}\n")),Object(a.b)("p",null,"GraphQL Config is able to generate a schema not only as ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," object, but also as a ",Object(a.b)("inlineCode",{parentName:"p"},"DocumentNode"),". (For more info, read the API reference of ",Object(a.b)("a",{parentName:"p",href:"/graphql-project-config"},Object(a.b)("inlineCode",{parentName:"a"},"GraphQLProjectConfig")),".)\nIt's also capable of loading operations and fragments."),Object(a.b)("h2",{id:"registering-loaders"},"Registering Loaders"),Object(a.b)("p",null,"In previous examples, we pointed GraphQL Config to the ",Object(a.b)("inlineCode",{parentName:"p"},"schema.graphql")," file. GraphQL Config, by default, understands the Introspection result stored in JSON file, GraphQL files (",Object(a.b)("inlineCode",{parentName:"p"},".graphql"),", ",Object(a.b)("inlineCode",{parentName:"p"},".gql"),", ",Object(a.b)("inlineCode",{parentName:"p"},".graphqls")," and ",Object(a.b)("inlineCode",{parentName:"p"},".gqls"),") and the document returned by any functioning GraphQL endpoint (specified by URL)."),Object(a.b)("p",null,"In some cases, you may want to extend that behavior and teach GraphQL Config how to look for GraphQL SDL (modularized schema for example) across many JavaScript or TypeScript files."),Object(a.b)("p",null,"It's now possible thanks to ",Object(a.b)("strong",{parentName:"p"},"loaders"),"."),Object(a.b)("p",null,"The ",Object(a.b)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools"},"GraphQL Tools")," library has ",Object(a.b)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools/tree/master/packages/loaders"},"a few already written loaders")," that GraphQL Config uses. We mentioned the default loaders, but the repo contains a few extra ones."),Object(a.b)("p",null,"For simplicity, we're going to use only ",Object(a.b)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools/tree/master/packages/loaders/code-file"},"the one")," responsible for extracting GraphQL SDL from code files."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"import {CodeFileLoader} from '@graphql-tools/code-file-loader';\n\nconst InspectorExtension: GraphQLExtensionDeclaration = (api) => {\n  // Lets schema\n  api.loaders.schema.register(new CodeFileLoader());\n  // documents\n  api.loaders.documents.register(new CodeFileLoader());\n\n  return {\n    name: 'inspector',\n  };\n};\n")),Object(a.b)("p",null,"Let's say you have GraphQL SDL modularized across multiple TypeScript files, written like this:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-typescript"},"import {gql} from 'graphql-tag';\n\nexport const typeDefs = gql`\n  type User {\n    id: ID!\n    name: String!\n  }\n\n  extend type Query {\n    user(id: ID!): User!\n  }\n`;\n")),Object(a.b)("p",null,"With ",Object(a.b)("inlineCode",{parentName:"p"},"CodeFileLoader")," you can extract those GraphQL pieces:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"schema: './src/modules/*.ts' # uses a glob pattern to look for files\nextensions:\n  inspector:\n    validate: true\n")),Object(a.b)("p",null,"There are two kinds of loaders. One is responsible for handling schemas, and the other covers Operations and Fragments (we call them both ",Object(a.b)("inlineCode",{parentName:"p"},"Documents"),")."),Object(a.b)("p",null,"To read more about loaders, please check ",Object(a.b)("a",{parentName:"p",href:"/loaders"},'"Loaders" chapter')))}p.isMDXComponent=!0},93:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return b}));var o=t(0),r=t.n(o);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),p=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},m=r.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,b=d["".concat(i,".").concat(m)]||d[m]||u[m]||a;return t?r.a.createElement(b,s(s({ref:n},l),{},{components:t})):r.a.createElement(b,s({ref:n},l))}));function b(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);